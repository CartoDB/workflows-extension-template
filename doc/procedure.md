# Writing the component procedure

The component procedure should be implemented in the `fullrun.sql` and `dryrun.sql`. files. The first of them should contain the code to be executed when running a workflow that contains the component. The second one should contain code that generates tables with the same schema as the ones generated by the full run code, but with zero rows, in order to provide a more efficient way of having the schema of the output tables. When a dry-run is performed, the procedure should create the table in the passed output path, but it should be an empty table, which will be used to figure out the output schemas of the component.

## Variables

For implementing the logic of the component, you will have available a set of variable matching the names of the parameters declared in the `metadata.json` file, with both input and output parameters. These variables will contain the values selected by the user when configuring the component as part of a workflow.

Additionally, the following variables will also be available, containing the values of certain environment variables that provide information about the context in which the workflow and the component are being executed:

-   `analyticsToolboxDataset`
-   `analyticsToolboxVersion`
-   `apiBaseUrl`
-   `accessToken`
-   `dataExportDefaultGCSBucket`
-   `bigqueryProjectId`
-   `bigqueryRegion`

Below you can see an example of a stored procedure built following the approach defined above. This procedure takes a table and generates a new one that includes and additional column with a unique identifier.

`fullrun.sql`:

```sql
        EXECUTE IMMEDIATE '''
        CREATE TABLE IF NOT EXISTS ''' || output || '''
        OPTIONS (expiration_timestamp = TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL 30 DAY))
        AS SELECT *, GENERATE_UUID() AS uuid
        FROM ''' || input || ';';
```

`dryrun.sql`:

```sql
        EXECUTE IMMEDIATE '''
        CREATE TABLE IF NOT EXISTS ''' || output || '''
        OPTIONS (expiration_timestamp = TIMESTAMP_ADD(CURRENT_TIMESTAMP(), INTERVAL 30 DAY))
        AS SELECT *, GENERATE_UUID() AS uuid
        FROM ''' || input || '''
        WHERE 1 = 0;
        ''';
```

The `input` and `output` variables will contain the names of the input table that was configured for the component, and the name of the output one generated by the component. Parameters with those same names should have been declared in the corresponding `metadata.json`file.

Do not generate tables with names others than the ones provided in the variables corresponding to output parameters. Otherwise, those tables will not be used when the component output is connected to another component in the workflow.

## Table names and API execution

When a workflow is run from the Workflows UI, table names of the tables created by its components are fully qualified. That means that, if your custom component is connected to an upstream components and uses a table from it, the name that it will received in the corresponding parameter will be a FQN (that is, in the form `project.dataset.table`). Output names received in the output parameters will also be FQNs.

However, when the workflow is run as a stored procedure (when exported or when executed via API), all tables created in components are session tables that are single names (that is, something like `tablename` instead of `project.dataset.table`). That means that inputs that come from other components, and also output table names, will be single-name tables.

You should prepare your component to deal with this situation. Check the input/output table names to see whether they are fully-qualified or not, and implement the corresponding logic to run in each case.
